{ False extensions }


{ less-than }
3 4 < {T}  ∫  4 3 > {T}  ∫
4 4 < {F} ~∫  4 4 > {F} ~∫
5 4 < {F} ~∫  4 5 > {F} ~∫

{ greater-than -- not an extension but included for completeness }
3 4 > {F} ~∫  4 3 < {F} ~∫
4 4 > {F} ~∫  4 4 < {F} ~∫
5 4 > {T}  ∫  4 5 < {T}  ∫

{ less-than-or-equal-to }
3 4 ≤ {T}  ∫  4 3 ≥ {T}  ∫
4 4 ≤ {T}  ∫  4 4 ≥ {T}  ∫
5 4 ≤ {F} ~∫  4 5 ≥ {F} ~∫

{ greater-than-or-equal-to }
3 4 ≥ {F} ~∫  4 3 ≤ {F} ~∫
4 4 ≥ {T}  ∫  4 4 ≤ {T}  ∫
5 4 ≥ {T}  ∫  4 5 ≤ {T}  ∫

{ not-equal-to }
3 4 ≠ {T}  ∫
4 4 ≠ {F} ~∫
5 4 ≠ {T}  ∫


{ 22 4 /MOD . . 5 2 ok }
22 4 1ø1ø1ø1ø/*-@@/ 5=∫ 2=∫

22 4 ÷ 5=∫ 2=∫

{ modulo in: x,y out:x mod y }
[1ø1ø/*-]m:

 0 5 m;! 0=∫
 1 5 m;! 1=∫
 4 5 m;! 4=∫
 5 5 m;! 0=∫
 6 5 m;! 1=∫
 9 5 m;! 4=∫
10 5 m;! 0=∫
11 5 m;! 1=∫
13 5 m;! 3=∫

[Ø/*-]m:

 0 5 m;! 0=∫
 1 5 m;! 1=∫
 4 5 m;! 4=∫
 5 5 m;! 0=∫
 6 5 m;! 1=∫
 9 5 m;! 4=∫
10 5 m;! 0=∫
11 5 m;! 1=∫
13 5 m;! 3=∫

 0 5 ÷%  0=∫
 1 5 ÷%  1=∫
 4 5 ÷%  4=∫
 5 5 ÷%  0=∫
 6 5 ÷%  1=∫
 9 5 ÷%  4=∫
10 5 ÷%  0=∫
11 5 ÷%  1=∫
13 5 ÷%  3=∫


{ bitwise left shift }
 1 0 «  1=∫
 1 1 «  2=∫
 1 2 «  4=∫
 1 3 «  8=∫

{ bitwise right shift }
10 0 » 10=∫
10 1 »  5=∫
10 2 »  2=∫
10 3 »  1=∫
10 4 »  0=∫


{ xor }

{ XOR(a,b) = AND(OR(a,b), NOT(AND(a,b))) }
[$@$@|@@&~&]x:

0 0 x;! 0= ∫
0 1 x;! 0=~∫
1 0 x;! 0=~∫
1 1 x;! 0= ∫

{ using 2dup }
[Ø|@@&~&]x:

0 0 x;! 0= ∫
0 1 x;! 0=~∫
1 0 x;! 0=~∫
1 1 x;! 0= ∫

{ using xor operation }
0 0 ⊻   0= ∫
0 1 ⊻   0=~∫
1 0 ⊻   0=~∫
1 1 ⊻   0= ∫


{ stack depth }
         §0=∫
10       §1=∫ %
20 10    §2=∫ %%
30 20 10 §3=∫ %%%

{ over }
10 20 \$@\  10=∫ 20=∫ 10=∫
10 20 £     10=∫ 20=∫ 10=∫

{ nip }
10 20 \% 20=∫ §0=∫
10 20 ‰  20=∫ §0=∫

{ tuck }
10 20 $@\  20=∫ 10=∫ 20=∫
10 20 €    20=∫ 10=∫ 20=∫

{ dup2 }
10 20 30 0ø      30=∫           30=∫ 20=∫ 10=∫ §0=∫
10 20 30 1ø1ø    30=∫ 20=∫      30=∫ 20=∫ 10=∫ §0=∫
10 20 30 Ø       30=∫ 20=∫      30=∫ 20=∫ 10=∫ §0=∫
10 20 30 2ø2ø2ø  30=∫ 20=∫ 10=∫ 30=∫ 20=∫ 10=∫ §0=∫


{ reverse }
§0=∫        ®  §0=∫
10          ®  10=∫
10 20       ®  10=∫ 20=∫
10 20 30    ®  10=∫ 20=∫ 30=∫
10 20 30 40 ®  10=∫ 20=∫ 30=∫ 40=∫

{ reverse implemented using variables -- does not scale }
10 20 30 40
a:b:c:d:
a;b;c;d;
10=∫ 20=∫ 30=∫ 40=∫

{ reverse implemented using pick -- appending to stack  }
{         depth 40 30 20 10 }
{ pick 1: depth 40 40 30 20 10 }
{ pick 3: depth 30 40 40 30 20 10 }
{ pick 5: depth 20 30 40 40 30 20 10 }
{ pick 7: depth 10 20 30 40 40 30 20 10 }
10 20 30 40
§ [$0>] [$§\-1-ø \1-] # %
10=∫ 20=∫ 30=∫ 40=∫
{ clean-up }
§ [$0>] [\%1-] # %

{ reverse implemented using roll }
{         depth 40 30 20 10 }
{ roll 2: depth 30 40 20 10 }
{ roll 3: depth 20 30 40 10 }
{ roll 4: depth 10 20 30 40 }
10 20 30 40
§ [$1>] [$§\-™ \1-] # %
10=∫ 20=∫ 30=∫ 40=∫


{ roll }
10 20 30 40 0™     40=∫ 30=∫ 20=∫ 10=∫
10 20 30 40 1™     30=∫ 40=∫ 20=∫ 10=∫
10 20 30 40 2™     20=∫ 40=∫ 30=∫ 10=∫
10 20 30 40 3™     10=∫ 40=∫ 30=∫ 20=∫
10 20 30 40 §1-™   10=∫ 40=∫ 30=∫ 20=∫


{ if-then-else }
3 4 = [ 0 ∫ ][ 0~∫ ]¿
4 4 = [ 0~∫ ][ 0 ∫ ]¿
5 4 = [ 0 ∫ ][ 0~∫ ]¿


{
// https://en.wikipedia.org/wiki/Euclidean_algorithm#Implementations
function gcd(a, b)
    while b ≠ 0
        t := b
        b := a mod b
        a := t
    return a
}

10 15 [$0=~][$@$@$@\/*-]#%  5=∫
10 15 [$0≠][$@$@$@\/*-]#%   5=∫
10 15 [$0≠][€Ø/*-]#%        5=∫  { tuck, 2dup }
10 15 [$0≠][€÷%]#%          5=∫  { tuck, /MOD }

[[$0≠][€÷%]#%]g:

10 15 g;! 5=∫
49 21 g;! 7=∫

